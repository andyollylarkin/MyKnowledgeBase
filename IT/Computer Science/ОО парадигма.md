---
aliases: [ООП, обьектно ориентированное программирование, прототипно ориентированное программирование, обьект, прототип, ОО]
tags: [basis, terminology, design, paradigms, oop, programming, ]
---
# ОО [[парадигма]]
<h6>12-04-2022</h6>
----------
## Определение
[[Парадигма]] программирования, где во главу угла ставятся объекты. ПО моделируется этими объектами.





### Объектно ориентированная [[парадигма]]
4 свойства присущие ООП парадигме:
- [[Абстракция]]
- [[Инкапсуляция]]
- [[Полиморфизм]]
- [[Наследование]]

#### Наследование типов и наследование реализации
%%Описать что интерфейс помимо того, что он является механизмом задания контракта еще является механизмом определения типа, и реализация интерфейса это более правильный подход к наследованию. В тоже время наследование классов это наследование реализации%%

#### Статично-Классовая ориентированность
В классово ориентированной организации ООП присутствует понятие класса и сущности (instance)(обьект), принадлежащей данной классификации. Обьекты часто называют экземплярами класса.
Класс представляет собой формальное [[Абстракция|абстрактное]] множество обобщенных характеристик сущности. Понятие [[множество]] в этом отношении более близко к математике, однако можно говорить о типе или классификации.

```python
class Some:
	def __init__(self): # метод
		self.a = 10 # атрибут, характеристика
		self.b = 20 # атрибут, характеристика
		self.c = 30 # атрибут, характеристика
```
К характеристикам сущностей относятся свойства (описание обьекта) и [[Парадигма#Отличия подпрограммы от функции|методы]](метод это та же функция, только в терминологии ООП называемая методом). 

Сами характеристики также могут быть представлены обьектами.

При этом обьекты хранят свое состояние (конкретные значения всех свойств, описанных в классе), а классы определяют жесткую структуру (т.е. наличие тех или иных свойств) и жесткое поведение (наличие методов) своих экземпляров.

**Иерархическое наследование**
>Как известно ООП стало дальнейшим развитием императивной парадигмы >которое привнесло механизм наследования реализации для увеличения >переиспользуемости кода.

Разрешение имен методов при вызове методов из экземпляра осуществляется по жестким, неизменным, заданным программистом в коде последовательном опросе классов на наличие того или иного метода. Если метод найден в родном классе, будет опрошен класс родитель. Если не найден в родителе, то будет опрошен его родитель и т.д. по цепочке.
>Если по достижении базового класса цепи метод не будет найден, то это будет считаться ошибкой.

Основной недостаток иерархического наследования это - если какие то атрибуты или методы не нужны в классе потомке, при наследовании он всё равно будет их иметь. Второй недостаток - хотя методы не копируются по цепи наследования и разрешаются в ней ведя поиск по цепочке, свойства в свою очередь копируются напрямую в класс потомок. Копируются физически, т.е. занимают доп. память. Опять же если эти свойства нам не нужны, то мы тратим память в пустую.

#### Ключевые моменты классовой модели
- Чтобы породить обьект, нужно перед этим описать класс на основе которого этот обьект будет порожден
- При этом обьект будет порожден в точности согласно спецификации описанной в классе.
- Разрешение методов осуществляется по жестко заданной цепи наследования
- Классы потомки при иерархическом наследовании содержат все свойства цепи наследования даже если потомок не нуждается в этих свойствах.
- Будучи порожденным обьект не может изменить набор своих характеристик, имея только те, что были описаны в классе 

## Прототипно ориентированная [[парадигма]]
> Представители: Lua, JS
#### Прототипная ориентированность
В отличии от классовой модели в прототипной не существует классов. Вместо них есть обьекты которые могут динамически мутировать по ходу выполнения программы. 
Мутация означает, что мы можем изменять не только значения атрибутов, но и сам состав этих атрибутов.

```javascript
let obj = {a: 10, b: 20, c: 30} // obj это конкретный обьект существующий в памяти
obj.a; // 10
obj.b; // 20

// добавляем динамически свойство в обьект obj
obj.d = 40
obj.d; // 40. Теперь obj имеет новый атрибут d
```
При присвоении, если определенный атрибут существует в обьекте, то значение будет обновлено, если атрибута нет, то он создается и инициализируется переданным значением.

Повторное использование кода в данном случае достигается не за счет наследования классов, а за счет обращения к обьекту прототипу.

> _Прототип (Prototype)_ — это объект, служащий _либо прообразом_ для других объектов, _либо вспомогательным объектом (делегатом), к характеристикам которого может обратиться оригинальный объект_, в случае, если сам оригинальный объект не обладает нужной характеристикой.

---
## Библиография
- С.А. Орлов - Теория и практика языков программирования
- С.Макконел - Совершенный код
- [Блог Дмитрия Сошникова - Тонкости ECMA-262-3. Часть 7.1. ООП: Общая теория. ](http://dmitrysoshnikov.com/ecmascript/ru-chapter-7-1-oop-general-theory/)
