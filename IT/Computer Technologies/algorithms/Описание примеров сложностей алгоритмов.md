---
aliases: []
tags: [algos,alg,algorithms,bigo,big-o]
---
# Описание примеров сложностей алгоритмов
<h6>09-09-2022</h6>
----------
## Определение
[[Об Big-O нотации|см. О Big-O Нотации]]

## Примеры

![[Pasted image 20220909192000.png]]

|**Сложность/Размер**|10|1000|10000|
|----|----|----|----|
|**1 - константная**||||
|**n - линейная**|0.01 sec.|1 sec.|10sec.|
|**log<sub>2</sub>n**|0.003 sec.|0.01 sec.|0.013 sec.|
|**n log<sub>2</sub>n**|0.03 sec. |10sec.|130 sec.|
|**n<sup>2</sup>**|0.1 sec|16 min. 6667 sec.| 27 h.|
|**2<sup>n</sup>**|1.024 sec.|очень много| очень много|
|**n!**|невообразимо много|невообразимо много|невообразимо много|

> Расчет выше в предположении, что 1 операция выполняется за 1мс. Конечные значения в секундах (мс. / 1000)

### O(n) - линейная сложность
Такой сложностью обладает например алгоритм поиска наибольшего элемента в не отсортированном [[Массив|массиве]]. Данная сложность означает, что нам нужно пройтись по всем входным данным, не зависимо от только, сколько их. Если [[массив]] отсортирован, то сложно уже будет **O(1)** потому, что мы точно знаем, что максимальный элемент будет находится на последней позиции и можем просто взять его по индексу, а операции взятия по индексу в [[Массив|массиве]] имеет сложность **O(1)**

### O(log<sub>2</sub> n) - логарифмическая сложность
Пример - бинарный поиск. Если [[массив]] отсортирован, мы можем проверить, есть ли в нем конкретное значение, методом деления пополам.
Ключ к пониманию, что сложность именно **O(log<sub>2</sub>n)** является именно понимание, что **входные данные нужно делить пополам на каждой итерации цикла**. 

### O(n<sup>2</sup>) - квадратичная сложность
Такую сложность имеет, например, алгоритм [[Сортировка|сортировки]] вставками. В канонической реализации он представляет из себя **два вложенных цикла**. Кол-во операций при этом будет n * n или - O(n<sup>2</sup>)


---
## Библиография
- 
