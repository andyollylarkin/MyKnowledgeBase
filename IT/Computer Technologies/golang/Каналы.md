---
aliases: [chan, go channels, go каналы]
tags: [go, gonang, basis]
---
# Каналы
<h6>24-09-2022</h6>
----------
## Определение
Канал похож на [[Unix Pipe]]. Каналы предназначены для коммуникации между [[Горутина|горутинами]] , принимая и отправляя в них значения. 

> Каналы имеют ссылочный тип и по умолчанию их значение = _nil_

## Обьявление типа
*ChannelType = ( "chan" | "chan" "<-" | "<-" "chan" ) ElementType*
Где:
- *chan <-* - только принимающий канал,
- <- chan - только отправляющий канал
- chan - принимающий и записывающий
- ElementType - тип элемента который будет записан в канал

## Инициализация канала
```go
make(chan int, 100) // где chan int - тип канала, 100 вместимость канала
```

## Закрытие канала
Закрыть канал можно встроенной функцией - *close()*


## Каналы и дедлок
><span style="color:red">fatal error: all goroutines
are asleep — deadlock!</span>

Такое сообщение об ошибке можно увидеть, когда две [[Горутина|горутины]] взаимодействуют с одним каналом. Если первая [[горутина]] будет читать из канала, в котором будет пусто, то процесс переключится на другую горутину, которая уже возможно ничего не пишет в канал, или вообще закончила свое исполнение, следовательно первая [[горутина]] окажется **вечно заблокированной**, это называется **[deadlock](https://ru.wikipedia.org/wiki/%D0%92%D0%B7%D0%B0%D0%B8%D0%BC%D0%BD%D0%B0%D1%8F_%D0%B1%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)**.
![[Pasted image 20220924181944.png]]

#### Пример
```go
package main  
  
import (  
   "sync"  
)  
  
func main() {  
   var wg sync.WaitGroup  
   ch := make(chan int)  
   wg.Add(1)  
   go func() {  
      ch <- 1 // тут произойдет блокировка и собственно дедлок, потому что никто не будет читать из канала
   }()  
  
   wg.Wait()  // Ждем выполнения анонимной горутины выше, иначе программы завершится быстрее чем мы увидим сообщение об ошибке
}
```


### Пример deadlock в одной и той же горутине

```go
package main  
  
func main() {  
   var ch chan int  
   ch = make(chan int)  
   ch <- 1  
   println(<-ch)  
}
```

Этот код приведет к следующей ошибке:
><span style="color:red">fatal error: all goroutines
are asleep — deadlock!</span>

Дело в том, что оба оператора как чтения так и записи в канал блокируют горутину пока принимающая сторона не получит значение. В данном случае блокировка будет тут:
```go
ch <- 1  
```
Единица запишется в канал, после чего [[горутина]] заблокируется. А т.к. и чтение и запись происходят в одной [[Горутина|горутине]], то произойдет взаимоблокировка (deadlock).

## Буферизованные и небуферизованные каналы
Канал может быть с буфером или без
```go
var ch chan int = make(chan int, 0) // без буфера
var ch chan int = make(chan int, 2) // буфер на 2 элемента
```
Если канал пустой, то [[горутина]]-получатель блокируется, пока в канале не окажутся данные. Когда [[горутина]]-отправитель посылает данные, [[горутина]]-получатель получает эти данные и возобновляет работу.

### Пример в одной и той же горутине с дедлоком
```go
func main() {  
   var ch = make(chan int, 0)  
   ch <- 2  // блокировка main поскольку канал полон и из него 
   // никто не будет читать, потому что операция чтения находится
   // в той же горутине (т.е. заблокированой)
   println(<-ch)  
}
```

### Пример в одной и той же горутине без блокировки
На примере ниже можно увидеть, что канал может быть с буфером(в данном случае на 2 элемента). 
```go
func main() {  
   var ch = make(chan int, 2)  
   defer close(ch)  
   ch <- 2  
   println(<-ch) // спокойно читаем, т.к. буфер не полный,
   // следовательно горутина не будет заблокирована
   // println(<-ch) - deadlock, т.к. в канале нет элементов для чтения и больше их туда не запишут.  
}
```
На примере выше буфер канала равен 2, и туда записали один раз. Когда размер буфера больше 0, [[горутина]] не блокируется до тех пор, пока буфер не будет заполнен. Следовательно можно из не полного канала читать в одной и той же [[Горутина|горутине]].


---
## Библиография
- [Каналы изнутри](https://habr.com/ru/company/oleg-bunin/blog/522742/)
