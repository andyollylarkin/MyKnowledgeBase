---
aliases: [context, ctx, контекст go, golang контекст]
tags: [go, golang,basis,]
---
# Контексты
<h6>07-11-2022</h6>
----------
## Определение
Пакет определяющий тип _Context_ переносящий, крайние сроки и значения через границы [[API]] и процессы. 



### Пример
```go
package main  
  
import (  
   "context"  
   "fmt"   
   "time"
   )  
  
func main() {  
   ctx, cancel := context.WithCancel(context.Background())  
   defer cancel()  
   go func() {  // горутина выполняющаяся в отдельном потоке, которая запрашивает ввод с клавиатуры и блокируется до его получения. После получения она вызывает функцию cancel которую вернул context созданный выше.
      println("Scan?")  
      _, _ = fmt.Scanln()  
      println("Before cancel")  
      cancel()  
   }()  
   processLongTask(ctx) // начало обработки длинной задачи. Тут происходит блокировка.  
}  
  
func processLongTask(ctx context.Context) {  
   ch := make(chan int, 1)  
OUTER:  
   for {  
      ch <- 1  
      time.Sleep(time.Second)  
      select {  // select блокирует дальнейшее выполнение пока не получит данные в канал в одном из case. В данном случае т.к. ctx.Done() канал пуст, данные получаются из ch канала. Как только в коде выше будет получаен ввод с клавиатуры в горутине, произойдет разблокировка и будет вызвана функция cancel. Функция calcel закрывает канал
      case i := <-ch:  
         fmt.Printf("%s: %d\n", "Job iter: ", i)  
      case <-ctx.Done():  
         println("Execution canceled")  
         break OUTER  
      }  
   }}
```

#### Почему при вызове close разблокируется канал возвращаемый ctx.Done

В коде выше при получении ввода вызывается **close()**, что приводит к разблокировке [[Горутина|горутины]] _main_ и чтению из _ctx.Done_ канала. Все дело в том, что при попытке прочитать из закрытого канала мы получим значение по умолчанию.

>После закрытия канала мы не сможем послать в него новые данные. Если мы попробуем это сделать, то получим ошибку. Однако мы можем получить ранее добавленные данные. Но при попытке получить данные из канала, которых нет, мы получим значение по умолчанию.
>https://metanit.com/go/tutorial/7.3.php

```go
package main  
  
func main() {  
   var ch chan int  
   ch = make(chan int)  
   go func() { // запуск отдельной горутины которая закроет канал 
      for i := 0; i < 1_000_000_000_0; i++ {  
  
      }      
      close(ch)  // закрываем канал
   }()  
   println("Sleep until channel be closed") // после запуска горутины выше будет выведено это значение и ниже произойдет блокировка до тех пор пока счетчик не дойдет до 1_000_000_000_0
   select {  
   case <-ch:  // как только счетчик дойдет до конца канал закроется и мы получим возможность прочитать из этого канала значение по умолчанию - в данном случае 0
      println("Channel was close")  
      break  
   }  
}
```


---
## Библиография
- [Go context package doc](https://pkg.go.dev/context#example-WithCancel)
- 