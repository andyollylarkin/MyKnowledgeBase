---
aliases: [variables, go variables, переменные в go, переменные в golang, golang обьявление переменных]
tags: [go, golang, basis]
---
# Переменные
<h6>23-09-2022</h6>
----------
## Определение
> Go статически типизированный язык со строгой типизацией и выводом типов

## Объявление переменных
**Нотация: _\[var\] <var_name> \{<var_type>\} = \<expression\>_**

Любая из частей _<var_type>_ или \<expression\> может быть опущена, но не обе одновременно. Если опущено выражение, то нужно обьявить тип, т.к. переменная обязательно должна иметь тип, поскольку язык статически типизирован, если опущен тип, то должно быть выражение. В этом случае переменная примет значение по умолчанию для данного типа

|Тип|Начальное значение|
|---|---|
|bool|false|
|числа|0|
|Строки|""|
|Интерфейсы и ссылочные типы ([[срезы]], указатели, отображения(map), [[каналы]], функции)|nil|

## Walrus оператор
В Go поддерживается walrus оператор
```go
a := 10
// or
var a = 10
// but not
var a = 10
a := 11
```
Моржовый оператор это *сокращение от объявления var и присваивания значения*. Если переменная уже объявлена, то компилятор не даст в эту же переменную присвоить новое значение с помощью моржового оператора. Вместо этого нужно делать так:
```go
var a int = 10
a = 11
```

## Области видимости
- Глобальная
- Локальная

Локальные переменные обьявляются внутри скобок {}.
> Для локальных переменных допустим краткий вариант записи _<var_name> **:=** \<expression\> . При этом формате записи тип выводится компилятором.

Глобальные в свою очередь обьявляются вне тела функций, и доступны в любом месте внутри пакета или вне его.

## Константы
Аналогично другим языки, фактически защищенные от повторной записи участки памяти.
```go
const <const_name> = <expression>
```

## Параметры и результат функций
Параметры функции так же являются переменными доступными внутри локального блока в функции.
```go
func some(a int32, b int32) int64{
	return int64(a + b)
}

func some2(a int32, b int32) (c int64){
	c = int64(a + b)
	return // неявно вернет c
}
```

В первой функции имеются 2 параметра (a и b) и результат типа _int64_.
Функция _some2_ в свою очередь возвращает так же _int64_, но в этом случае параметр именованный, т.е. в примере выше нам не нужно объявлять переменную _c_ по скольку она уже неявно объявлена в месте объявления возвращаемого результата функции. Так же мы пишем просто **return**, что неявно так же значит, что будет возвращена _с_.

> По сути **а,b** являются _IN_ параметрами, а **_c_** _OUT_ параметром.




---
## Библиография
- 
