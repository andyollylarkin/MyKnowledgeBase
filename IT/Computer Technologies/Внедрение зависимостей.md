---
aliases: [dependency injection, DI, IoC, IoC container, service locator]
tags: [oop, basis, principles, design, concept]
---
<h6>01-12-2022</h6>
----------
## Определение
Процесс предоставления внешней зависимости программному компоненту. В соответствии с [[Разделение ответственности|принципом единcтвенной ответственности]] объект отдает заботу о построении требуемых ему внешних зависимостей специальному механизму по внедрению этих самых зависимостей.

### Пример
[см. Пример кода на PHP](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8#%D0%9F%D1%80%D0%B8%D0%BC%D0%B5%D1%80_%D0%BA%D0%BE%D0%B4%D0%B0_%D0%BD%D0%B0_PHP)

## Зачем?
Допустим есть следующий код:
```php
class Parser
{
	public function getPage($url){
		return $this->load($url);
	}
	private function load($url){
		return file_get_contents($url);
	}
}

class Exchanger
{
	public function getRate($currency){
		return $this->load('...?id=' . $currency);
	}
	private function load($url){
		return file_get_contents($url);
	}
}

$parser = new Parser();
$parser->getPage('...');

$exchanger = new Exchanger();
$exchanger->getRate('USD');
```
Два класса выше имеют дублирующийся по функционалу метод ```load```.
Есть два пути решения проблемы:
1. От наследовать *Parser* от *Exchanger* (или наоборот, не суть важно). При этом не понятно, по какому принципу произошло это [[наследование]], и почему у класса Exchanger есть метод *getPage* (или опять же наоборот у *Parser* есть *getRate*). Так же метод load попросту не будет унаследован потому что он приватный.
2. Можно создать базовый класс *Loader* с методом *load* и унаследовать оба класса от него. При таком решении проблемы, если у нас в обоих классах будет использоваться еще подобные общие методы, то как поступать в этом случае? Вынести его в Loader опять же не получится, потому что нарушится консистентность публичного [[Интерфейс|интерфейса]]. Если создать еще один класс со своей функциональностью, то мы не сможем сделать множественное [[наследование]].
3. Можно создать третий класс *Loader* и внедрить его в качестве зависимости в оба класса *Parser* и *Exchanger* (через конструктор или прямо в нужный метод). При этом данный подход будет реализован не через [[Наследование|наследование]] , а через [[Делегирование|делегацию]](см определение №2) и композицию. 

DI в двух словах вместо прямой зависимости на некоторый конкретный класс (require, import, new) предоставляет зависимости через конструктор/параметр метода/метод сеттер. Т.е. ключевой момент внедрения зависимостей, это независимость некоторого объекта от другого объекта, а получение его извне, что уменьшает [[Cohesion and coupling|связанность]] кода.

## Плюсы и минусы

### Плюсы:
- Упрощает [[Тестирование|тестирование]] за счет того, что при тестировании можно будет передать упрощенный (mock [[ОО парадигма|обьект]]) классу. Например не [[Паттерн Repository|SqlRepository]], а MockRepository. При этом при тесте [[ОО парадигма|обьект]] не полезет в реальную базу данных за данными, а получит их из фейкового, заранее настроенного объекта репозитория.
- Уменьшает [[Cohesion and coupling|связность]] кода.
### Минусы:
- При излишнем использовании подхода с внедрением зависимостей может сделать приложение более сложным для понимания и поддержки, т.к. в исходном коде мы не понимаем какой инстанс класса будет реально подан классу при динамической диспетчеризации.

## DI Container
DI-контейнер в первую очередь отвечает за создание объектов, а лишь во вторую — за их хранение. В DI-контейнере может вообще не хранится ни одного созданного объекта, если само приложение не нуждается в объектах, общих для всего приложения (типа конфигурации или логгера).

## Service Locator
Локатор служб - [[ОО парадигма|обьект]] предоставляющий доступ одним объектам к другим объектам. Локатор представляет собой контейнер в который можно положить **готовые** объекты (или задать правила их создания) и затем получить к ним доступ. Локатор отвечает за хранение обьектов и предоставление к ним доступа.

### Отличия SL от DI
>**SL** работает по принципу *pull*: конструктор "вытягивает" из контейнера свои зависимости. **DI** работает по принципу *push*: контейнер передает в конструктор его зависимости.


---
## Библиография
- [Википедия](https://ru.wikipedia.org/wiki/%D0%92%D0%BD%D0%B5%D0%B4%D1%80%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8)
- [DI Container & Service Locator - Habr](https://habr.com/ru/post/465395/)