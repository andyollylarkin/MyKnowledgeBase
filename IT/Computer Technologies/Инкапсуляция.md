---
aliases: [incapsulation, information hiding,]
tags: [basis, oop, design, principles, abstraction]
---
<h6>16-04-2022</h6>
----------
## Определение


### Врезка из статьи Сергея Типлякова
> Тэд Фейсон (Ted Faison) в своей книге [“Event-Based Programming”](http://www.amazon.com/Event-Based-Programming-Taking-Events-Limit/dp/1590596439) вводит аксиому управления зависимостями, которая звучит следующим образом:
_Чем сложнее класс или компонент, тем меньше у него должно быть внешних связей._  
(The more complex a class or component is, the more decoupled it should be)
Если посмотреть на реальные системы, над которыми мы работали, то можно вспомнить, что мы, пусть неосознанно, но действовали именно таким образом. **В чем смысл абстракции и инкапсуляции? В защите внутренней реализации класса от внешних клиентов, а также, что более важно, в защите наших клиентов от сложности нашей реализации. Смысл проектирования заключается в том, чтобы использование класса было проще его внутренней реализации**.

### Мой ответ на тостере
> В том беда современного обучения программированию, что учат ООП на наследовании кошечек и собачек от абстрактных животных, а нахера это делать и зачем это появилось не учат. Плохая для вас новость - вы не поймете прелести подхода пока не проработаете хотя бы годик на реальном проекте. Но понять сам ООП вы можете не работая. Попытаюсь натолкнуть вас на мысль, и обьяснить истоки, откуда пошло ООП и зачем, через какое-то время вы осознаете эти концепции. Итак.  
Когда мы пишем программу, мы так или иначе моделируем какую-то часть реальности. Модель это несовершенное представление самой этой реальности, с выделенными атрибутами необходимыми для нашей решаемой задачи (абстрагирование, один из принципов ООП), например детская игрушка самолет, это модель реального самолета который копирует лишь внешний реального самолета, при этом игнорируется его внутреннее устройство, и игрушка таким образом не умеет летать, но наша задача (развлечь ребенка) при этом выполняется.  
Существует несколько парадигм праграмирования. Каждая [[парадигма]] это стиль моделирования программы. Затронем например процедурное программирование. В нем существуют для моделирования задачи такие сущности как: структуры данных и процедуры которые эти структуры обрабатывают. Дело в том, что в программе есть всего две еденицы которыми мы управляем: данные и поведение. Структуры данных это собственно данные, процедуры это поведение. Смысл зачем появилось процедурное программирование именно чтобы дать программисту абстрагировать поведение (засунуть код обработки данные в именованную сущность, она еще называется функция или процедура). Что это нам дает? Раньше у нас была простыня кода которая расчитывала например зп сотрудников, если нам нужно было посчитать зп в разных местах нам нужно было копипастить эту простыню. А сначала нужно было разобраться что простыня делает. Это сложно. Теперь у нас появилась именованная сущность (процедура) которпя имеет метку имени calculateSalary. Ну и что? А то, что теперь нам во первых не нужно копипастить код, во вторых (в идеале) не нужно разбираться как он работает. Мы просто знаем что calculateSalary считает зп для сотрудника. Как оно это делает, нам совершенно похер. Снизилась когнитивная нагрузка на мозг при моделировании задачи и повысилась переиспользуемость кода, тем самым сократилось время разработки. Но умные люди на этом не остановились и стали развивать идею дальше. Дальше они подумали, что не плохо было бы обьеденить в одной сущности данные и действия над этими данными, назвали это обьектами, которые могут формироваться на основе классов. Теперь у нас обьеденены данные и процедуры в одной именованной сущности (это инкапсуляция). Подробнее об инкапсуляции можете почитать в другом моем ответе [https://qna.habr.com/q/1174988#answer_2194198](https://qna.habr.com/q/1174988#answer_2194198)  
В общем вы не поймете прелесть ООП пока не поработаете по той причине, что нужно набрать массу сложности в проекте, которую генерируете как вы сами так и другие программисты, и не поймете прелесть повторного использования кода которое дает ООП, потому что у вас нет горящих сроков. Тут еще можно в целом много чего написать на тему ООП, но я бы вам посоветовал следующие книги:  
  Стив Макконел - Совершенный код  
Гради Буч - Обьектно ориентированный анализ и проектирование  
Сергей Типляков - Паттерны проектирования на платформе .NET (это вместо банды четырех, т.к. там более современно раскрывается тема паттернов, не пугайтесь что она про C# .NET, книга в самом деле очень хорошая)  
  Так же список терминов на погуглить  
GRASP - Information Expert  
Information Hiding  
Software Complexity (это то откуда всё начинается, управление сложностью)  
Cohesion & Coupling  

---
## Библиография
- [Статья Сергея Типлякова](http://sergeyteplyakov.blogspot.com/2013/02/blog-post.html)
