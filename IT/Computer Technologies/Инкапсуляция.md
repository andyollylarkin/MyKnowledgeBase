---
aliases: [incapsulation, information hiding,]
tags: [basis, oop, design, principles, abstraction]
---
<h6>16-04-2022</h6>
----------
## Определение
Процесс разделения элементов абстракции, определяющих ее структуру (данные) и поведение (методы). На практике - класс должен состоять из двух частей [[Интерфейс|интерфейса]] и реализации. 
Данное понятие схоже с [[Абстрактный тип данных|АТД]] тем, что как и [[Абстрактный тип данных|АТД]] инкапсуляция  показывает пользователю интерфейс, но ограждает его от реализации.

#### О Java
>В Java инкапсуляция понимается как механизм, связывающий код и данные, которыми он манипулирует, **защищая** оба этих компонента от внешнего вмешательства и злоупотреблений. Инкапсуляцию можно считать защитной оболочкой, которая предохраняет код и данные от произвольного доступа со стороны другого кода, находящегося снаружи оболочки. Доступ к коду и данным, находящимся внутри оболочки, **строго контролируется тщательно определённым интерфейсом**


#### Связь инкапсуляции и сокрытия информации(information hiding)
>Можно думать, что сокрытие информации является принципом, а инкапсуляция - методом. Программный модуль скрывает информацию, инкапсулируя информацию в модуль или другую конструкцию, представляющую интерфейс

### Врезка из статьи Сергея Типлякова
> Тэд Фейсон (Ted Faison) в своей книге [“Event-Based Programming”](http://www.amazon.com/Event-Based-Programming-Taking-Events-Limit/dp/1590596439) вводит аксиому управления зависимостями, которая звучит следующим образом:
_Чем сложнее класс или компонент, тем меньше у него должно быть внешних связей._  
(The more complex a class or component is, the more decoupled it should be)
Если посмотреть на реальные системы, над которыми мы работали, то можно вспомнить, что мы, пусть неосознанно, но действовали именно таким образом. **В чем смысл абстракции и инкапсуляции? В защите внутренней реализации класса от внешних клиентов, а также, что более важно, в защите наших клиентов от сложности нашей реализации. Смысл проектирования заключается в том, чтобы использование класса было проще его внутренней реализации**.

Из вышесказанного Сергеем можно сделать следующий вывод. Что утрата инкапсуляции ведет к утрате контроля за изменением состояния и обеспечением [[Инвариант|инвариантов]].

### Мой ответ на тостере
> В том беда современного обучения программированию, что учат [[ОО парадигма|ООП]] на наследовании кошечек и собачек от абстрактных животных, а нахера это делать и зачем это появилось не учат. Плохая для вас новость - вы не поймете прелести подхода пока не проработаете хотя бы годик на реальном проекте. Но понять сам [[ОО парадигма|ООП]] вы можете не работая. Попытаюсь натолкнуть вас на мысль, и обьяснить истоки, откуда пошло [[ОО парадигма|ООП]] и зачем, через какое-то время вы осознаете эти концепции. Итак.  
Когда мы пишем программу, мы так или иначе моделируем какую-то часть реальности. Модель это несовершенное представление самой этой реальности, с выделенными атрибутами необходимыми для нашей решаемой задачи (абстрагирование, один из принципов [[ОО парадигма|ООП]]), например детская игрушка самолет, это модель реального самолета который копирует лишь внешний реального самолета, при этом игнорируется его внутреннее устройство, и игрушка таким образом не умеет летать, но наша задача (развлечь ребенка) при этом выполняется.  
Существует несколько парадигм праграмирования. Каждая [[парадигма]] это стиль моделирования программы. Затронем например процедурное программирование. В нем существуют для моделирования задачи такие сущности как: структуры данных и процедуры которые эти структуры обрабатывают. Дело в том, что в программе есть всего две единицы которыми мы управляем: данные и поведение. Структуры данных это собственно данные, процедуры это поведение. Смысл зачем появилось процедурное программирование именно чтобы дать программисту абстрагировать поведение (засунуть код обработки данные в именованную сущность, она еще называется функция или процедура). Что это нам дает? Раньше у нас была простыня кода которая рассчитывала например зп сотрудников, если нам нужно было посчитать зп в разных местах нам нужно было копипастить эту простыню. А сначала нужно было разобраться что простыня делает. Это сложно. Теперь у нас появилась именованная сущность (процедура) которая имеет метку имени calculateSalary. Ну и что? А то, что теперь нам во первых не нужно копипастить код, во вторых (в идеале) не нужно разбираться как он работает. Мы просто знаем что calculateSalary считает зп для сотрудника. Как оно это делает, нам совершенно похер. Снизилась когнитивная нагрузка на мозг при моделировании задачи и повысилась [[Повторное использование кода|переиспользуемость кода]], тем самым сократилось время разработки. Но умные люди на этом не остановились и стали развивать идею дальше. Дальше они подумали, что не плохо было бы обьеденить в одной сущности данные и действия над этими данными, назвали это обьектами, которые могут формироваться на основе классов. Теперь у нас обьеденены данные и процедуры в одной именованной сущности (это инкапсуляция). Подробнее об инкапсуляции можете почитать в другом моем ответе [https://qna.habr.com/q/1174988#answer_2194198](https://qna.habr.com/q/1174988#answer_2194198)  
В общем вы не поймете прелесть [[ОО парадигма|ООП]] пока не поработаете по той причине, что нужно набрать массу сложности в проекте, которую генерируете как вы сами так и другие программисты, и не поймете прелесть повторного использования кода которое дает [[ОО парадигма|ООП]], потому что у вас нет горящих сроков. Тут еще можно в целом много чего написать на тему [[ОО парадигма|ООП]], но я бы вам посоветовал следующие книги:  
  Стив Макконел - Совершенный код  
Гради Буч - Обьектно ориентированный анализ и проектирование  
Сергей Типляков - Паттерны проектирования на платформе .NET (это вместо банды четырех, т.к. там более современно раскрывается тема паттернов, не пугайтесь что она про C# .NET, книга в самом деле очень хорошая)  
  Так же список терминов на погуглить  
GRASP - Information Expert  
Information Hiding  
Software [[Сложность|Complexity]] (это то откуда всё начинается, управление сложностью)  
[[Cohesion and coupling|Cohesion]] & [[Cohesion and coupling|Coupling]]  

---
## Библиография
- [Статья Сергея Типлякова](http://sergeyteplyakov.blogspot.com/2013/02/blog-post.html)
- [Wikipedia - Information hiding](https://en.wikipedia.org/wiki/Information_hiding)