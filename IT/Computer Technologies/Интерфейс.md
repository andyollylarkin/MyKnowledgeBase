---
aliases: [interface, наследование интерфейса, oop interface, интерфейсы, интерфейса]
tags: [basis, oop, interface, terminology, concept, conception]
---
# Интерфейс
<h6>16-04-2022</h6>
----------

## Определение
Публичное API объекта, которое рассказывает какие операции могут быть применимы к данному [[Тип данных|типу]].

При грамотном подходе к конструированию ПО в [[ОО парадигма|ОО]] парадигме, мы проектируем объекты в виде [[Абстрактный тип данных|АТД]] . Мы скрываем внутреннюю реализацию нашего типа, предоставляя клиентам операции которые применимы к нашему объекту. Понятие интерфейса неразрывно связано с такими понятиями как [[Полиморфизм]], Сокрытие информации, [[Абстракция]]. 

## Пример:
![[Pasted image 20220615163310.png]]

На данной [[UML]] диаграмме изображен [[Абстрактный тип данных|АТД]] Stack. Он имеет [[Инкапсуляция|инкапсулированные]] данные (Counter: int), о которых нам не важно знать, и мы не можем получить к ним на прямую доступ, и публичный интерфейс (increase,decrease,getCounter). Т.е. все операции которые может выполнить наш [[тип данных]] Stack (все сообщения которые он готов принять), видны пользователю через этот интерфейс.

Синтаксическая конструкция **Interface** имеющаяся во многих языках это как раз и есть интерфейс взаимодействия, вернее его прямая поддержка языком. При отсутствии в языке явной поддержки этой конструкции мы можем определять интерфейсы на уровне соглашений (что конечно же не так очевидно и удобно и более подвержено ошибкам). 
Таким образом интерфейс это контракт, который обязуется выполнить [[ОО парадигма|обьект]] который реализовал данный интерфейс.
Т.е. если бы Stack из примера выше был бы интерфейсом, то мы точно были бы уверены, что у него можно вызвать операции (increase,decrease,getCounter).

## Связь интерфейсов LSP и контрактного программирования
Интерфейс как программная сущность гарантирует потребителю только то, какие члены в нем присутствуют
> Обычно интерфейс описывает только методы некоторого типа. Но такой язык как TypeScript может описывать и какие поля могут (должны) присутствовать в типе.

Но интерфейс не гарантирует ничего по поводу реализации. То есть известно, что обьект который соответствует некому интерфейс обладает необходимым поведением (по факту соответствует сигнатуре метода), но не гарантирует ничего поведении самой реализации. Для решения этой проблемы было изобретено [[контрактное программирование]]. Контрактное программирование обуславливает в устной или письменной форме, придерживаться не только формального интерфейса в виде списка методов, но и так же что сопраженная с реализацией логика будет соответствовать неким критериям. Например что интерфейс List который имеет метод Add добавит (обязательно добавит) в коллекцию один и только один элемент. Этого нельзя описать формально на уровне языка программирования, только путем устных или письменных договоренностей.

## Отличия абстрактного класса от интерфейса (как синтаксической конструкции языка)
- Абстрактный класс - представляет из себя элемент кода который может содержать как частичную реализацию, так же при этом являясь [[Тип данных|типом]]
- Интерфейс - является только [[Тип данных|типом]].
> Если в абстрактном классе все методы помечены абстрактными, то семантически абстрактный класс и интерфейс - эквивалентны.

---
## Библиография
-  [Интерфейс - Википедия](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81_(%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5))
- [Интерфейсы в TypeScript](https://scriptdev.ru/guide/021/#_1)
- GOF
- С. Макконел - глава про АТД
- Р. Седжвик - Алгоритмы на JAVA - 1.2 - Абстракция данных
