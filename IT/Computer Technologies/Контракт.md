---
aliases: [contract,design by contract]
tags: [oop, solid,architecture,constraints,types,terms]
---
<h6>07-01-2023</h6>
----------
## Определение
Соглашение между вызывающим и вызываемым кодом о том что должен предоставить модулю вызывающий код, и что в ответ должен отдать вызываемый. При этом контракт так же определяет формальные требования к вызываемому, т.е. пред и пост условия.

> Можно сказать, что контракт это усиленная (предусловиями и постусловиями) версия [[Абстрактный тип данных|АТД]]

![[Инвариант#Определение]]


## Пример
Допустим есть базовый интерфейс *ICollection*. У него есть метод Add который принимает значение типа T, ничего не возвращая в ответ (т.е. return type - void). Формально вызывающий код должен подать на вход этому методу элемент типа T, и только его, т.е. Null так же не подходит. Это можно назвать предусловием контракта. С обратной стороны метод Add должен добавить в коллекцию элемент (обязательно должен добавить), ничего не возвращать. При этом можно наложить ограничивающее постусловие, что элемент в коллекцию данный метод должен добавить только один. При добавлении двух и более элементов в соотв. определения нашего контракта является его нарушением.

---
## Библиография
- [Сергей Типляков - Принцип замещения Лисков и контракты](https://habr.com/ru/post/139039/)