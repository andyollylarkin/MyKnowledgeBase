---
aliases: [ООП, обьектно ориентированное программирование, прототипно ориентированное программирование, обьект, прототип, ОО]
tags: [basis, terminology, design, paradigms, oop, programming, ]
---
# ОО Парадигма
<h6>12-04-2022</h6>
----------
![[programmini_principles.odt]]
## Определение
[[Парадигма]] программирования, где во главу угла ставятся объекты. ПО моделируется этими объектами.

>Основная идея - разбивать (*по их ответственностям*) сложную программу на отдельные объекты/компоненты, которые обмениваются сообщениями друг с другом. ОО парадигма про объекты и сообщения, а не про классы.


### Объектно ориентированная [[Парадигма]]
4 свойства присущие ООП парадигме:
- [[Абстракция]]
- [[Инкапсуляция]]
- [[Полиморфизм]]
- [[Наследование]]

#### Наследование типов и наследование реализации
> [[Интерфейс]] помимо того, что он является механизмом задания контракта еще является механизмом определения типа, и реализация [[Интерфейс|интерфейса]] это более правильный подход к наследованию. В тоже время [[Наследование]] классов это [[Наследование]] реализации.

#### Статично-Классовая ориентированность
В классово ориентированной организации ООП присутствует понятие класса и сущности (instance)(обьект), принадлежащей данной классификации. Обьекты часто называют экземплярами класса.
Класс представляет собой формальное [[Абстракция|абстрактное]] множество обобщенных характеристик сущности. Понятие [[множество]] в этом отношении более близко к математике, однако можно говорить о типе или классификации.

```python
class Some:
	def __init__(self): # метод
		self.a = 10 # атрибут, характеристика
		self.b = 20 # атрибут, характеристика
		self.c = 30 # атрибут, характеристика
```
К характеристикам сущностей относятся свойства (описание объекта) и [[Парадигма#Отличия подпрограммы от функции|методы]](метод это та же функция, только в терминологии ООП называемая методом). 

Сами характеристики также могут быть представлены объектами.

При этом объекты хранят свое состояние (конкретные значения всех свойств, описанных в классе), а классы определяют жесткую структуру (т.е. наличие тех или иных свойств) и жесткое поведение (наличие методов) своих экземпляров.

**Иерархическое наследование**
>Как известно ООП стало дальнейшим развитием императивной [[Парадигма|парадигмы]] > которое привнесло механизм наследования реализации для увеличения > переиспользуемости кода.

Разрешение имен методов при вызове методов из экземпляра осуществляется по жестким, неизменным, заданным программистом в коде последовательном опросе классов на наличие того или иного метода. Если метод найден в родном классе, будет опрошен класс родитель. Если не найден в родителе, то будет опрошен его родитель и т.д. по цепочке.
>Если по достижении базового класса цепи метод не будет найден, то это будет считаться ошибкой.

 - Основной недостаток иерархического наследования это - если какие то атрибуты или методы не нужны в классе потомке, при [[Наследование|наследовании]] он всё равно будет их иметь.
 - Второй недостаток - хотя методы не копируются по цепи наследования и разрешаются в ней ведя поиск по цепочке, свойства в свою очередь копируются напрямую в класс потомок. Копируются физически, т.е. занимают доп. память. Опять же если эти свойства нам не нужны, то мы тратим память в пустую.
 - Еще один недостаток, что после наследования от какого-то класса, базовый класс становится обязанным (т.е. должен поддерживать контракт) не только перед использующим его кодом, но и перед наследниками.

#### Ключевые моменты классовой модели
- Чтобы породить обьект, нужно перед этим описать класс на основе которого этот обьект будет порожден
- При этом обьект будет порожден в точности согласно спецификации описанной в классе.
- Разрешение методов осуществляется по жестко заданной цепи наследования
- Классы потомки при иерархическом [[Наследование|наследовании]] содержат все свойства цепи наследования даже если потомок не нуждается в этих свойствах.
- Будучи порожденным обьект не может изменить набор своих характеристик, имея только те, что были описаны в классе 

## Прототипно ориентированная [[Парадигма]]
> Представители: Lua, JS
#### Прототипная ориентированность
В отличии от классовой модели в прототипной не существует классов. Вместо них есть обьекты которые могут динамически мутировать по ходу выполнения программы. 
Мутация означает, что мы можем изменять не только значения атрибутов, но и сам состав этих атрибутов.

```javascript
let obj = {a: 10, b: 20, c: 30} // obj это конкретный обьект существующий в памяти
obj.a; // 10
obj.b; // 20

// добавляем динамически свойство в обьект obj
obj.d = 40
obj.d; // 40. Теперь obj имеет новый атрибут d
```
При присвоении, если определенный атрибут существует в обьекте, то значение будет обновлено, если атрибута нет, то он создается и инициализируется переданным значением.

[[Повторное использование кода]] в данном случае достигается не за счет наследования классов, а за счет обращения к обьекту прототипу.

> _Прототип (Prototype)_ — это объект, служащий _либо прообразом_ для других объектов, _либо вспомогательным объектом (делегатом), к характеристикам которого может обратиться оригинальный объект_, в случае, если сам оригинальный объект не обладает нужной характеристикой.


## Что такое хорошее ООП

#### Хорошее ООП:
1. Разгружает голову. Правильно называя методы, работая за один раз с одним уровнем абстракции используя более очеловеченную терминологию близкую к предметной области которую мы программируем мы уменьшаем [[сложность]] восприятия кода и понимания происходящего в этом коде. (см. [[Сложность]], [[Cohesion and coupling|coupling]], [[Абстракция]])
2. Привносит модульность. Группы объектов объединяются по своему смыслу в единый блок кода реализующий одну конкретную задачу. (см. [[Инкапсуляция]], [[Интерфейс]])
3. Повышает совместимость. [[Наследование#Наследование интерфейса и наследование реализации|Программируя на основе интерфейса, а не реализации]] мы можем заменять компоненты (классы), не затрагивая основной код, лишь бы интерфейс нового (замененного) обьекта совпадал с тем интерфейсом который ожидает вызывающий код.
4. Локализует изменения. Если меняются требования к ПО, то мы должны внести изменения в коде в одном месте, которое отвечает за обработку логики которую необходимо изменить.  Это контрастирует с процедурным лапшекодом, когда одна и та же логика дублируется в разных местах программы и при необходимости изменить логику - необходимо найти все места, где эта логика реализуется.
5. Абстрагируется от реализации (см. [[Абстракция]], [[Инкапсуляция|information hiding]]).

## Что является объектом, а что нет?
>Объектно-ориентированная парадигма отличается от процедурной и функциональной тем, что подразумевает создание объектов, хранящих свои данные и код для операций по работе с этими данными внутри себя, а не раздельно.
>[Структуры с процедурами или объекты?](https://elisdn.ru/blog/142/structs-or-objects)

Т.е. полноценный объект, это обьект хранящий в себе свое внутреннее состояние, сохраняющий свою целостность на протяжении своего жизненного цикла ([[Инвариант]]), и хранящий в этом же контейнере код для обработки этого состояния. "Хороший" обьект при этом не раскрывает своего внутреннего состояния [[Инкапсуляция|information hiding]], а выдает наружу только то, что с ним можно сделать ([[Интерфейс]]). 

---
## Библиография
- С.А. Орлов - Теория и практика языков программирования
- С.Макконел - Совершенный код
- [Блог Дмитрия Сошникова - Тонкости ECMA-262-3. Часть 7.1. ООП: Общая теория. ](http://dmitrysoshnikov.com/ecmascript/ru-chapter-7-1-oop-general-theory/)
