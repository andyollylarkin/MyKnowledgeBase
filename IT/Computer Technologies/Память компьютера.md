# Память компьютера
#cpu #computer #computerscience 
>**Бит** - минимальная единица хранения информации в памяти.
**Байт** - минимально **адресуемая** единица информации компьютером. 1 байт состоит из 8 бит (хотя существуют реализации с меньшим кол-вом бит или большим, напр. машинное слово (32 байта))
>
>Каждый байт имеет отдельный адрес который позволяет ЦПУ обращаться к определенному адресу. Адресация линейна, т.е. адреса идут от самого минимального к самому максимальному \[0x01, 0x02, ...\]

## Байтовая адресация
Предположим у нас имеется строка "hello". Тогда структура будет следующая.

|0x07|0x06|0x05|0x04|0x03|0x02|0x01|0x00||
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|-|-|-|h|e|l|l|o|Строковое представление|
|00000000|00000000|00000000|01101000|01100101|01101100|01101100|01101111|Байтовое представление|

Слово "hello" представлено в кодировке ASCII, где каждый символ кодируется одним байтом

0 − 127;2<sup>8</sup>−1
Один бит отводится под знак. Предположим мы производим эти манипуляции из языка Си который представляет строки в виде массива (в общем они так и представляются). Обратившись по адресу 0х00 мы получим значение в один байт мы получим число 111 в десятичной системе счисление, что отражает букву "о" в кодировке ASCII.
>Максимальный адресуемый адрес и разрядность системы. Если в ПК установлено допустим 16Гб RAM, но система является 32 разрядной(x86, i386), то система не сможет адресовать больше 2^32 (4294967296) байт, т.е. 4Гб памяти. Стартовый адрес при этом 0x0, конечный 0x100000000. Фактически же, в 32 битной системе такое ограничение вызвано тем фактом, что регистры процессора могут вместить только 32 битные значения, в 64 битной соотв. 64 битные значения (регистры с префиксом E (EAX, RAX, ...)).

## Порядок следовая байт в разных системах

В разных системах и средах может быть разный порядок следования байт. big endian и little endian. В системе BE байты следуют в своем прямом порядке, в LE в обратном. Например свово "hello" в BE = 0x68 0x65 0x6C 0x6C 0x6F в LE = 0x6F 0x6C 0x6C 0x65 0x68

## Машинное слово и выравнивание

Как упоминалось ранее, минимальной единицей адресации в процессоре является байт. Но фактически процессор считывает не отдельный байты, а машинные слово (WORD, DWORD (double word)) которое зависит от разрядности системы. В 32 разрядной системе размер машиного слова = 32 бита или 4 байта. Машинное слово есть единица информации которую процессор может обработать за один раз. Например за одну инструкцию сложения с помощью команды процессора ADD можно сложить только два регистра каждый из которых имеет размер не более машинного слова.

**Выравнивание:** для максимальной эффективности слова выравниваются по их естественным границам. Процессор обращается к каждому слову по адресам кратным двум. Если взять 32 битный процессор у которого машинное слово 32 бита (4 байта), то первый адрес ячейки к которому может обратиться процессор = 0х00, второй адрес 0x20 и т.д. . По этой причине машинное слово должно быть выравнено по этой естественной границе.

## Типы данных

На уровне архитектуры набора команд и ниже как таковых типов данных не существует. Однако в языках высокого уровня таком как Си есть понятие типизации данных

|Тип|Размер в байтах|
|:---:|:---:|
|byte|1|
|short|2|
|int|4|
|long|8|

При выделении в памяти для определенного типа данных, выделяется сразу необходимый блок равный размеру типа данных в системе (в разных системах может быть разный размер. В Си существует оператор sizeof() который может определить размер данных в системе в которой запущена программа). Так если мы выделим под переменную [[Тип данных]] int, то и запишем туда чисто 7, то в памяти это будет 0b111 и 29 остальных бит будет дополнено нулями (7 будет записано в младшие биты, дополнены будут старшие).

## Беззнаковые типы

[[Тип данных|Типы данных]] описанные выше могут быть так же знаковыми (**signed**). При беззнаковом (**unsigned**) типе максимальное число которое может записать в byte = 255. При знаковом типе максимальное значение = 127. -127 ... 0 ... 127. Для знаковых типов вводится специальная форма хранения (называемая [дополнительный код](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9_%D0%BA%D0%BE%D0%B4)), где самый старший бит в байте отведен под хранение знака (0 = +, 1 = -). По этому при знаковом типе
2<sup>8</sup>−1  = 128 (0 ... 127, отсчёт начинается с 0, поэтому 128, а не 127).

>Для примера возьмем выражение 7+(-5)
В двоичной системе 7 = 00000111, 5 = 00000101
7 - положительное число которое остается без изменений. -5 отрицательное, поэтому должно быть записано в доп. коде (см. ссылку выше). В старшем разряде выставляет бит знака (- = 1), остальные биты в числе инвертируем, получается -5 = 11111010, прибавляем к полученному числу 1: -5 = 11111011 - это число -5 представленное в доп. коде.
Итого получаем
00000111 + 11111011 = 0000010 или 2 в десятичной системе.

>Числовые типы являются примитивными (или как их еще называют скалярными) типами данных. Для них характерно, что при присвоении одного значения другому они передаются по значению, а не по ссылке. (см. [[Передача по ссылке и по значению]])

## Компьютерная арифметика
> см. [[Компьютерная арифметика]]


---
### Библиография
- Э. Таненбаум - Архитектура ПК