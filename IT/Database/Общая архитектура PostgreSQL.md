---
aliases: [архитектура postgres, архитектура postgresql, архитектура постгреса, СУБД postgres, архитектура СУБД]
tags: [db, postgres, postgresql, postgres_arch, database]
---
# Общая архитектура PostgreSQL
<h6>08-03-2022</h6>
----------
## Определение
Общее описание архитектура [[СУБД]] **PostgreSQL**.

## Описание

## Протокол взаимодействия
%%Стоит посмотреть через tcpdump еще раз, как выглядит этот протокол%%
Бинарный [[Протокол|протокол]] взаимодейсвия [[Протокол клиент-сервер|клиента и сервера]] [[СУБД]]. Взаимодействие происходит через драйвер БД
> Чаще всего драйвер использует реализацию протокола в библиотеке libpq

## Транзакции
[[Транзакция в БД|Транзакции]] должны выполнять четыре свойства [[ACID]] ![[ACID#Описание]]
## Выполнение запроса
Запрос передается от клиента на сервер ([[СУБД]]) в виде текста. Текст нужно разобрать - выполнить [[Синтаксический анализ|синтаксический разбор]] и [[Семантический анализ|семантический разбор]] (есть ли в БД указанные [[Реляционная алгебра и модель данных|таблицы]] и другие обьекта запроса, на которые ссылается запрос). Для этого требуется информация о том, что вообще есть в базе. Такая [[Метаинформация|метаинформация]] называется системным каталогом и хранится в самой бд.
>По скольку [[SQL]] декларативный язык запрос на нем говорит о том, какие данные нужно получить, но не говорит о том, как это сделать. По этому запрос (уже разобраный и представленный в виде [[Абстрактное синтаксическое дерево|дерева]]), передается планировщику, который разрабатывает план выполнения. [[Планировщик СУБД|Планировщик]] решает нужно ли использовать [[Индекс|индексы]] и т.д. Чтобы качественно спланировать выполнение запроса, планировщику необходима информация о размере [[Таблица|таблиц]] и о распределении данных - [[Статистика в БД|статистика]]. После этого запрос выполняется в соотв. с планом и результат возвращается клиенту.

## Подготовка запроса
Каждый запрос проходит шаги описанные выше. Но если один и тот же запрос (с точностью до параметров) выполняется много раз, нет смысла каждый раз заново его разбирать. Для этого в postgres имеется функционал подготовки запроса. В этом случае запрос заранее разбирается и трансформируется, и дерево запроса запоминается [[СУБД]]. К запросу могут быть привязаны параметры (если они не идентичны от запроса к запросу).

## Курсоры
Не всегда есть необходимость получать весь результат сразу. Данных может быть много и не все они нужны за раз. Для этого в [[СУБД]] предусмотрен механизм курсоров.
Открыв курсор можно получать данные из него построчно по мере необходимости.

## Процессы и память
Изнутри сервер PostgreSQL представляет несколько взаимодействующих [[Процесс|процессов]].
В первую очередь при старте сервера запускается [[Процесс]], называемый **postmaster** который запускает все остальные [[Процесс|процессы]] (с помощью [[Системный вызов|системного вызова]] **fork** в [[UNIX-like]] системах) и присматривает за ними. Если какой нибудь [[Процесс]] завершится аварийно, мастер [[Процесс]] перезапустит его (или перезапустит весь сервер, если сочтет, что упавший [[Процесс]] мог повредить данные). Чтобы процессы могли обмениваться информацией мастер процесс выделяет общую память ([[IPC]]). Так же каждый дочерний процесс имеет свою локальую память доступную только ему.
>%%описать с помощью каких системных вызовов это делается. Эту инфу можно найти в книге по Linux API%%

Чтобы клиент мог подключиться мастер процесс слушает входящие соединения. При появлении клиента **postmaster** порождает обслуживающий процесс (backend) и дальше каждый клиент общается со своим процессом.
>%%описать процесс соединения на сетевом уровне (что это tcp или udp?)%%

Место, необходимое для выполнения запроса (разобранные запросы и их планы, состояние курсоров, [[Кэширование|кэш]] системного каталога, место для сортировки данных и т. п.), выделяется в локальной памяти обслуживающего процесса.
![[Pasted image 20220308151534.png]]

## Подключение множества клиентов
Когда к серверу подключается множество клиентов, для каждого из них порождается собственный обслуживающий процесс. При одновременной работе с какими либо объектами БД необходимо принимать меры, чтобы один процесс не поменял какие-либо данные в то время пока с ними работает другой процесс.
Для объектов в общей памяти используются короткоживущие блокировки. 

С таблицами сложнее, т.к. блокировку придется удерживать до конца [[Транзакция в БД|транзакции]] (то есть потенциально долгое время). PostgresSQL использует механизм многоверсионности [[Изоляция и многоверсионность в PostgreSQL|MVCC]]: одни и те же данные могут одновременно существовать в разных версиях. Каждый процесс видит собственную версию. Это позволяет блокировать только те процессы, которые пытаются изменить данные, уже измененные, но еще не зафиксированные, другими процессами.
>**Многоверсионность — тот основной механизм, который обеспечивает первые три свойства транзакций**

## Пул соединений
Если клиентов много или соединения устанавливаются слишком часто
%%узнать механизм установления tcp соединений, накладные расходы на создание соединения%%, есть возможность применять пул соединений. Для этой функциональности есть менеджеры пулов (напр. [pgBouncer](https://www.pgbouncer.org/)). Клиенты в данном случае подключаются не к серверу БД на прямую, а к менеджеру пула.  Менеджер удерживает открытыми несколько соединений с сервером баз данных и использует одно из свободных для того, чтобы выполнять запросы клиента. Таким образом, с точки зрения сервера БД число клиентов остается постоянным вне зависимости от того, сколько клиентов обращаются к менеджеру пула.
> <span style='color:red'>При таком режиме работы несколько клиентов разделяют один общий процесс на сервере БД, соотвественно разделяя состояние и данные</span> 

## Хранение данных
PostgreSQL работает с дисками, на которых находятся данные, не напрямую, через средства ОС. Данные хранятся в обычных файлах и читаются или записываются с помощью соотв. [[Системный вызов|системных вызовов]]. 
>Из-за того, что диски работают значительно медленнее, чем оперативная память (особенно HDD, но и SSD тоже), применяется кэширование
>Кэш имеется как у операционной системы, так и у PostgreSQL. Кэш данных PostgreSQL (буферный кэш) располагается в общей памяти, чтобы все процессы имели к нему доступ.

![[Pasted image 20220308161819.png]]

---
## Библиография
- [Учебный курс от PostgresPRO](https://edu.postgrespro.ru/dba1/dba1_04_arch_general.pdf)
