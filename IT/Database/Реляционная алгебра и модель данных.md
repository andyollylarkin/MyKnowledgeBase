---
aliases: [relation, реляционная модель, реляционная алгебра, строка бд, таблицы, таблица, кортеж, кортежа, кортежи, домен, домены, домена, тип данных, типа данных, типы данных, атрибут таблицы]
tags: [db, database, relation_algebra, terminology, basis, foundation, set]
---
# Реляционная алгебра и модель данных
<h6>08-03-2022</h6>
----------

![](https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2Fi1Mb2UWbArGRW5ooFJbz%2Fuploads%2FAPeNdfkYIGhPdAG1032i%2Fimage.png?alt=media&token=e7b4de0f-902e-4639-98ee-7bed262133ab)

## Тип данных
Тип данных в РМД полностью адекватен понятию типа данных в языках программирования.

## Домен
Домен адекватен понятию [[Абстрактный тип данных|абстрактного типа данных]]

Домен определяет допустимое [[множество]] значений и операций над этими значениями.

От [[Абстрактный тип данных|АТД]] домен отличается тем, что значения которые он может принимать должны быть скалярными.

## Атрибут (столбец)
Именованные аргументы отношения. Атрибут это имя столбца в БД.

## Схема отношения

Схема это именованное [[множество]] пар имя атрибута, имя домена.

## Кортеж (строка)

Кортеж это [[множество]] пар имени атрибута и значения. На примере выше кортеж {номер сотрудника, 2934}.

## Отношение (таблица)
Отношение обычно имеет простую графическую интерпретацию в виде **таблицы**, столбцы которой соответствуют атрибутам, а **строки — кортежам**, а в «ячейках» находятся значения [[Реляционная алгебра и модель данных#Атрибут столбец|атрибутов]] в [[Реляционная алгебра и модель данных#Кортеж строка|кортежах]]. Тем не менее, в строгой реляционной модели _отношение_ не является _таблицей_, _кортеж_ — это не _строка_, а _атрибут_ — это не столбец. Термины «таблица», «строка», «столбец» могут использоваться только в неформальном контексте, при условии полного понимания, что эти более «дружественные» термины являются всего лишь _приближением_ и не дают точного представления о сути обозначаемых понятий.

В соответствии с определением [К. Дж. Дейта](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%B9%D1%82,_%D0%9A%D1%80%D0%B8%D1%81%D1%82%D0%BE%D1%84%D0%B5%D1%80 "Дейт, Кристофер"), таблица является прямым и верным представлением некоторого отношения, если она удовлетворяет следующим пяти условиям:

1.  Нет упорядочивания строк сверху вниз (другими словами, порядок строк не несёт в себе никакой информации).
2.  Нет упорядочивания столбцов слева направо (другими словами, порядок столбцов не несёт в себе никакой информации).
3.  Нет повторяющихся строк.
4.  Каждое пересечение строки и столбца содержит ровно одно значение из соответствующего [домена](https://ru.wikipedia.org/wiki/%D0%94%D0%BE%D0%BC%D0%B5%D0%BD_(%D0%B1%D0%B0%D0%B7%D1%8B_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) "Домен (базы данных)") (и больше ничего).
5.  Все столбцы являются обычными. «Обычность» всех столбцов таблицы означает, что в таблице нет «скрытых» компонентов, которые могут быть доступны только в вызове некоторого специального оператора взамен ссылок на имена регулярных столбцов, или которые приводят к побочным эффектам для строк или таблиц при вызове стандартных операторов. Таким образом, например, строки не имеют идентификаторов, кроме обычных значений потенциальных ключей (без скрытых «идентификаторов строк» или «идентификаторов объектов»). Они также не имеют скрытых временны́х меток



## Пересечение множеств или что не так с INNER JOIN?

>Таблица в РСУБД это не [[множество]]. [[Множество]] по определению не допускает дубликатов требуя чтобы все значения [[Множество|множества]] были уникальными.

[[Множество]] визуализаций в интернете показывают с помощью диаграм Венна, что результат операции INNER JOIN является пересечением множеств:
![](https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2Fi1Mb2UWbArGRW5ooFJbz%2Fuploads%2FIQ7dZPw5VqAQDtYjwf0N%2Fimage.png?alt=media&token=0ce70295-36cc-457a-b93f-10d0518ad7f8)

Но это не так.

```sql
-- создадим две таблицы
INSERT INTO table1
(id)
VALUES (1),(1),(3);
INSERT INTO table2
(id)
VALUES (1),(1),(2);
-- сделаем выборку
SELECT * FROM table1
INNER JOIN table2 ON table1.id = table2.id;
```

![](https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2Fi1Mb2UWbArGRW5ooFJbz%2Fuploads%2FGbz5ZiqeGPr3SnYC9Tuh%2Fimage.png?alt=media&token=45ce11aa-ec97-4ba4-a4d2-647ebf17cd60)

Действительно, результат пересечения в математическом понятии [[Множество|множества]] должен быть именно таким, т.к. мы исключили дублирование.

На практике [[СУБД]] выдаст:

![](https://files.gitbook.com/v0/b/gitbook-x-prod.appspot.com/o/spaces%2Fi1Mb2UWbArGRW5ooFJbz%2Fuploads%2FQN0FR8MOtBYeI65AjXzt%2Fimage.png?alt=media&token=9d3cb7f5-1a08-4c5e-b72d-30ee394949c4)

### Что не так?

Не так тут то, что вторая пара едениц является дублированием. Дело в том, что в теории реляционной алгебры предполагаются, что кортежи в отношении уникальны, следовательно можно считать совокупность кортежей отношения - множеством в математическом понимании. Но на практике [[СУБД]] не накладывают на отношения (таблицы) ограничения уникальности, следовательно на практике такие отношения считатся множеством не могут.

В самом деле INNER JOIN это не пересечение множеств (таблиц), а их декартово произведение (CROSS JOIN) с заданым условием.