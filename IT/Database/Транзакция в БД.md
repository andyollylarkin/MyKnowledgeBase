---
aliases: [транзакции, транзакция, тразакционность, изоляций транзакций, уровень изоляции, read uncommited, read commited, repeatable read, serializable]
tags: [db, database, transaction, transaction_isolation]
---
# Транзакция в БД
<h6>08-03-2022</h6>
----------
>В PostgreSQL (и вероятно других [[СУБД]]) каждый запрос в БД неявно заворачивается в транзакцию с уровнем изоляции по умолчанию для данной СУБД.

>Транзакции могут исполняться [[Параллельность|параллельно]] (имеется ввиду реальная параллельность, когда событие происходит реально в один и тот же промежуток времени) на многопроцессорной (многоядерной) системе.  

## Определение
Конечное множество операций над базой данных, выполняемое приложением, которое переводит базу данных из одного согласованного состояния в другое согласованное состояние, при условии что транзакция выполнена полностью и без помех со стороны других приложений.

Транзакции - механизм на уровне [[СУБД]] который обеспечивает требования [[ACID]]

## Различия между целостностью и согласованностью
- **Целостность** - определяется с помощью ограничений целостности, и [[СУБД]] предотвращает любые попытки нарушения этих ограничений
- **Согласованность** - может временно нарушаться нарушаться и восстанавливаться в конце выполнения транзакции

## Аномалии 
[[Изоляция и многоверсионность в PostgreSQL#Описание|Суть проблемы]]


>Аномалия - несогласованное состояние данных в БД.


### Потерянное обновление
Потерянное обновление это ситуация когда при одновременном изменении одного блока данных (блок может быть [[Реляционная алгебра и модель данных#Кортеж отношение строка|строкой]], [[Реляционная алгебра и модель данных#Отношение таблица|таблицей]] и т.д., не суть важно) разными транзакциями одно из изменений теряется.

```sql
-- Транзакция 1
BEGIN; 
SET TRANSACTION SET ISOLATION LEVEL READ UNCOMMITED; -- не поддерживается в Postgres
UPDATE test_table SET val = val + 100 WHERE pk = 1;

-- Транзакция 2
BEGIN;
SET TRANSACTION SET ISOLATION LEVEL READ UNCOMMITED; -- не поддерживается в Postgres
UPDATE test_table SET val = val + 50 WHERE pk = 1;

-- Любопытный факт: в psql даже не появится приглашение ко вводу при выполнении UPDATE во второй транзакции, если первая транзакция не завершена

```
Обе транзакции изменяют значение val на (<u>+100 и +50 соответственно</u>) и по завершению транзакций значение должно быть увеличено на 150.

Однако <u>может произойти</u> такая ситуация:

1. Обе транзакции одновременно читают текущее состояние поля (изначально 0). 
>Точная физическая одновременность здесь не обязательна, достаточно, чтобы вторая по порядку операция чтения выполнилась до того, как другая транзакция запишет свой результат.

2. Обе транзакции вычисляют новое значение прибавляя 100 к изначально прочитанному значению. 
3. Транзакции пытаются записать результат вычислений обратно в поле val. Поскольку физически одновременно выполнить две операции записи невозможно, одна [[Изоляция и многоверсионность в PostgreSQL#Если обе пишут тоже сложностей нет в этом случае они выстраиваются в очередь и пишут друг за другом|из операций записи будет выполнена раньше второй]] . При этом вторая операция записи перезапишет результат первой.

В результате значение поля val по завершении обеих транзакций может увеличится не на 150, а на 100 или на 50, т.е. результат одной из транзакций пропадет.

> Почему "<u>может произойти</u>"? Очевидно, что если транзакция 1 выполнит все операции и сделает **COMMIT**, и уже после этого транзакция 2 произведет свои операции, то такой проблемы не будет. Т.е. аномалия потерянного обновления происходит не постоянно.

### Грязное чтение
Чтение данных, добавленных или измененных транзакцией, которая впоследствии не подтвердится (откатится, или произойдет иной сбой).
```sql
-- Транзакция 1
BEGIN;
SET TRANSACTION SET ISOLATION LEVEL READ UNCOMMITED;
UPDATE test_table SET val = val + 100 WHERE pk = 1;

-- В это время другая транзакция (все запросы в СУБД завернуты в транзакцию, по этому тут говорится "транзакция", хотя явно в запросе она может быть и не указана)
SELECT * FROM test_table WHERE pk = 1;

-- Транзакция 1
ROLLBACK;
```

В этой этом случае "Транзакция 2" прочитает данные которые позже не будут записаны, и [[Протокол клиент-сервер|клиент]] получит несогласованные данные, полученные данные будут отличаться от тех что в хранятся в базе.
> <span style='color: red'>Опять же READ UNCOMMITED явно не поддерживается в PostgreSQL, и уровень изоляции по умолчанию будет READ COMMITED который как раз устраняет грязное чтение, поэтому увидеть на практике такое чтение, не получится.</span>

### Неповторяющееся чтение

Ситуация, когда при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными.

```sql
-- Транзакция 2
BEGIN;
SET TRANSACTION SET ISOLATION LEVEL READ COMMITED;
SELECT * FROM test_table WHERE pk = 1;

-- Транзакция 1
BEGIN;
SET TRANSACTION SET ISOLATION LEVEL READ COMMITED;
UPDATE test_table SET val = val + 100 WHERE pk = 1;
COMMIT;

-- Транзакция 2

SELECT * FROM test_table WHERE pk = 1;
```

В транзакции 2 выбирается значение из БД, затем транзакция 1 изменяет данные и делает фиксацию изменений. При повторной выборке транзакцией 2 она получит уже измененные данные.
> Данный вид аномалии устраняет уровень изоляции **REPEATABLE READ**


### Фантомное чтение
Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

```sql
-- Транзакция 2
BEGIN;
SET TRANSACTION SET ISOLATION LEVEL READ COMMITED;
SELECT * FROM test_table; -- выборка всех данных

-- Транзакция 1
BEGIN;
SET TRANSACTION SET ISOLATION LEVEL READ COMMITED;
INSERT INTO test_table (pk, val) VALUES(2, 200);
COMMIT;

-- Транзакция 2
SELECT * FROM test_table; -- выборка всех данных
```

Транзакция 2 читает все данные из [[Реляционная алгебра и модель данных#Отношение таблица|таблицы]] в транзакции. Транзакция 1 выполняет вставку новых значений в таблицу. Транзакция 2 снова читает все данные и получает уже другой результат.

## Уровни изоляции транзакций

#### Определение
Определенные в стандарте SQL уровни [[Изоляция и многоверсионность в PostgreSQL|изоляции транзакций]]. Каждый уровень имеет разное влияние на поведение чтения и записи в [[СУБД]].
Степень изоляции определяется в терминах аномалий. Степень изоляции обеспечивает сама [[СУБД]] (то есть не требует специального программирования).

> <span style='color: green'>Каждый последующий уровень изоляции включает в себя предыдущий.</span>

### READ UNCOMMITED
> Не поддерживается в PostgreSQL

Позволяет читать не зафиксированные данные (не выполнен оператор **COMMIT**)

Низший (первый) уровень изоляции. Если несколько параллельных транзакций пытаются изменять одну и ту же строку [[Реляционная алгебра и модель данных#Отношение таблица|таблицы]], то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.

### READ COMMITED
> Используется по умолчанию в PostgreSQL

Снимок строится на момент начала оператора. Одинаковые запросы могут каждый раз получать разные данные.
В транзакции, работающей на этом уровне, запрос **SELECT** (без предложения **FOR UPDATE/SHARE**) видит только те данные, которые были зафиксированы до начала запроса; он никогда не увидит незафиксированных данных или изменений, внесённых в процессе выполнения запроса параллельными транзакциями.

Защищает от [[Транзакция в БД#Грязное чтение|грязного чтения]]. При этом если результаты другой транзакции работающей с теми же данными зафиксированы, то текущая транзакция будет работать с уже измененным набором значений.

> Реализация этого уровня изоляции может быть выполнена либо с помощью [[Изоляция и многоверсионность в PostgreSQL#Блокировки|блокировок]], либо с помощью [[Изоляция и многоверсионность в PostgreSQL#Описание|версионирования]]

### REPEATABLE READ
Уровень, при котором читающая транзакция «не видит» изменения данных, которые были ею ранее прочитаны. При этом никакая другая транзакция не может изменять данные, читаемые текущей транзакцией, пока та не окончена.
Предотвращает анималию [[Транзакция в БД#Неповторяющееся чтение]].

### SERIALIZABLE
Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «[[Транзакция в БД#Фантомное чтение|фантомного чтения]]».

### Поведение при различных уровнях изолированность
|Уровень изоляции|Фантомное чтение|Неповторяющееся чтение|Грязное чтение|Потерянное обновление|
|---|---|---|---|---|
|SERIALIZABLE|+|+|+|+|
|REPEATABLE READ|-|+|+|+|
|READ COMMITED|-|-|+|+|
|READ UNCOMMITED|-|-|-|+|

---
## Библиография
- Б.А. Новиков - Основы технологий баз данных, гл. 6
- [Документация PostgresPRO](https://postgrespro.ru/docs/postgrespro/10/transaction-iso#XACT-READ-COMMITTED)